- 分布式系统的难题
    - 通信问题
        - 消息可能重复
        - 消息可能乱序
        - 消息可能丢失
    - 宕机问题
        - 宕机后状态是否正确
        - 重启后状态是否正确
    - 脑裂问题（一些思考）
        - 分布式系统leader角色依赖于别人的认可
        - 当别人认可和自身leader状态不一致时，便产生了脑裂
- 保持副本的一致性
    - 中心数据库
        - 设立一个中心对外交互，并对内拷贝
        - 中心的不可靠
    - quorum
        - 读和写的交集+可传递，保证了一致性
    - lease
        - 主服务器对下属服务器做出的一个，带有有终点时间（即当前时间+一个间隔）的承诺（需要同步时间？）
        - 例如：
            - primary的承诺
            - cache不变的承诺
        - 正确性
            - 通信
                - 重发不影响终点
                - 乱序会选取最大的终点的那个
                - 丢失不会造成影响
            - 宕机
                - 宕机：保持承诺不变
                - 重启，等待一个间隔，等待的过程中保持间隔不变
        - 共识算法
            - 问题
                - 在一轮决议，多台机器propose
                - 每一轮至多选出一个决议
            - 形式化的描述
                - safeness：在每一轮中，各个机器且记录下的决议是一致的（空或者对应的proposal）
                - liveness：在每一轮中，不能每次都选空
            - 前提条件
                - 每个proposal 都有一个编号，即< num, val >
                - 每台机器都会accept 它第一个遇到的决议
            - 对于一致性的保证
                - 一致性的保证
                    - 每个被chosen的决议val是一致的
                    - 每个被accept的决议是一致的
                    - 每个被propose的决议是一致的
                - 基本思想，quorum
                    - 每次chosen条件是，需要一个quorum 都accept 该决议
                    - 当相邻编号的proposal被chosen时，这两个quorum会有交集
                    - 可以利用这个交集，去改变后chosen的决议，使得后chosen的决议的val 和 前一个决议val相同
                - 步骤
                    - 服务器端：确定所提出的决议
                        - 第一轮需要查询是否有这个交集
                            - 确定一个proposal：<b, val>
                            - 向所有机器询问，上一轮是否投给了其它人（即作为交集）
                        - 第二轮根据这个上一轮查询的结果，改变该决议的val
                            - 若机器接收到上一轮有投给其它人的机器存在，即改变val
                            - 发出决议，看是否被其它人accept
                    - 客户端：维持自己的承诺
                        - 第一轮
                            - 当接收到其它机器的查询时，它需要确认上一轮是否投票
                            - 当确认结果后，它就不能再改变上一轮的结果了，即不在accept了 < n的结果
                        - 第二轮
                            - 当接收到其它机器的要求投票时，它要确认自己能不能投，即若承诺的x > n，就不能投
                                - 如果遇到了 承诺的 x < n呢
                            - 当没有的话就投票
                - 安全性
                    - 通信问题
                        - message的丢失
                            - 第一轮的消息丢失，没有影响，不会造成决议被提出
                            - 第二轮的消息丢失，没有影响，因为保证已经被满足
                        - message的重发
                            - 第一论的消息重发，没有影响
                            - 第二轮的消息重发，没有影响
                        - message的乱序
                            - 第一轮的消息乱序，即一个更大的决议比更小的决议先到，
                    - 宕机问题
                        - 重启
                            - propose重启
                            - acceptor重启
                        - 
- 分布式事务的一致性
    - 对于所有机器，要么全部提交，要么全部失败
    - 两阶段提交
        - 即单机必须知道其它的机器都可以提交后才能提交，这就导致了两步
            - 第一步，单机需要了解其它机器是否可以提交（主机发送prepare，接收消息并广播）
            - 第二步，根据相应消息提交，这步如果网络出现问题则出现活锁，即有的机器已经提交，其它机器也必须提交，不提交不行，只能一直重发
    - 三阶段提交
    - MVCC
        - 单机MVCC
            - 类似于git/svn？ ![image.jpg](../assets/7ac1a7d1-1942-4191-8378-02aaae3aee80-1115003.jpg)
                - 事务B合并时，如果不发生冲突，则正确合并，否则commit失败
            - 多版本的实现方式
                - 数据拷贝成多个版本
                - 记录更新操作，读取时（基础版本+更新操作）
        - 分布式MVCC
            - 每台机器的操作，记录为< transaction_num, op >
            - 当全部机器（quorum？）都完成某个transaction，在全局元信息中记录
            - 当读取时，只读取全局元信息中最大的那个transaction对应的编号的数据
- 附
    - 追加是的数据不会造成冲突（即读和写不会对同一个元素产生）
