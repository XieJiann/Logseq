- 分治模式
    - **分解**原问题为若干子问题，这些子问题是原问题的规模较小的实例
    - **解决**这些子问题，递归的求解子问题。然而若子问题规模较小，直接求解
        - 递归情况：当子问题足够大时，递归求解
        - 基本情况：
            - 与原问题不一样的基本问题
            - 规模更小的原问题
    - **合并**这些子问题的解成原问题的解
- 最大子数组问题（也有动态规划的求解）：核心是避免重复计算，利用之前的计算
    - 分解
    - 解决
        - 递归到更小的
        - 当子数组长度为1时，当前最大值肯定它本身
    - 合并
        - 最大子数组合并可能存在三种情况
            - 最大子数组是左子数组的最大值
                - 合并花销为O(1)
            - 最大子数组是右子数组的最大值
                - 合并花销为O(1)
            - 最大子数组跨越的中间值
                - 以中间值为起点，分别找到两边最大值，最坏情况是最大值是这个子数组全部和O(len(sub_array))
    - 思考
        - 1、空数组问题：可以递归时，加一个判断，当子数组为空时返回0
        - 2、动态规划解决
            - 设置全局最优解、局部最优解；
            - 局部最优解是包含最新元素的最大值、全局是整体最大值；
            - local_i+1 = max(local_i+A(i+1),A[i+1])
            - global_i+1 = max(global_i,local_i+1)
- 矩阵乘法A*B
    - 原始解法：三层循环
        - 1、遍历A的行
        - 2、遍历B的列
        - 3、遍历A的行和B的列的每一个元素，计算它们的乘积之和
    - 分治：Strassen算法，待详细看
- 代入法
- 递归树的方法
- 主方法
