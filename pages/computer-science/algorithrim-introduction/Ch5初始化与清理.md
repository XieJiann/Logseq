- 初始化
    - 成员初始化
        - 局部变量未初始化会报错
        - 其他默认初始化
    - 初始化顺序
        - 定义的先后顺序，并先于构造器前初始化（**先于任何方法**）
        - 静态数据：初始化为NULL，必要时初始化
    - 构造器
        - 编译器会创建一个无参的默认构造器
        - 当显示的定义一个构造器时，编译器便不会创建
- 方法重载：参数列表区分不同方法
- this关键字：指代本对象
    - 可以使用this(argu...) 在构造器中调用其他构造器（先声明的）
    - static方法与类（而非实例）绑定，不存在this
- 清理：终结处理和垃圾回收
    - finalize()：可以在类中定义该函数，在该类被垃圾回收的时候执行
        - 和析构函数的区别是：Java中类不一定会被回收，只有在堆空间不足的时候才会做垃圾回收
        - 用处：
            - 可以用来销除一些以本地方法（类似与malloc而不是new）申请堆空间。（**不推荐使用**）
            - 可以作为终结条件的验证，即在垃圾回收时通过finalize()函数做一些验证
    - 垃圾回收
        - 申请空间的方式：堆指针向前移动
        - 确定垃圾的方式
            - 引用计数
                - 当有对象引用时，引用+1，反之-1；当引用计数为0时，代表其为垃圾
                - 缺陷：当出现循环引用时，尽管是垃圾，但引用计数永远不为1
            - 树（参见CSAPP）
                - 每一个对象之间的相互引用构成一个图
                - 每一个non-dead对象 能够追朔到 栈或静态存储区的引用
        - 垃圾回收技术
            - 停止-复制
                - 设置两个堆
                - 当需要垃圾回收时，停止程序的运行；把non-dead对象从一个堆复制到另一个堆（复制的过程也是紧凑的过程）
                - 当对象复制的时候，其地址会发生改变，解决的方法是设置一个表，将旧地址映射到新地址
                - 缺陷是开销较大：复制的开销大，设置两个堆维护开销大
            - 标记-清扫（垃圾很少的情况）
                - 只是遍历整个图，标记non-dead对象
                - 标记完成之后，释放对象（产生很多碎片）
