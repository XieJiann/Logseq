- 脏数据：事务未提交，写的内容（这里指的是Roll back，即还没有写到磁盘）
	- 如果是两阶段加锁/time stamp/可行性验证，则不会读到未提交的事务写的内容
	- 否则，则需要级联回滚所有利用到了脏数据的事务（利用undo undo/redo log）
- 可恢复的执行顺序（这里指的是Recovery，crash后从磁盘恢复）：即这里的条件是对可恢复性的保证
	- log 的 committed 顺序 和 它们写的顺序一样（放在可串行化中，即它们的执行顺序是一样的）
	- 注：可串行化和可恢复性无相关性
		- 可串行化关注的执行顺序，缺少对提交的关注
		- 可恢复性关注的最后的committed顺序
- ACR：Avoiding Cascading rollback，ACR条件：（比可恢复的保证要更严格）
	- 只读committed事务写的内容，即避免读到脏数据
	- ACR 一定是可恢复的
- 严格锁：利用锁实现的ACR
	- 直到committed或中止，并写入磁盘日志中后，才释放排他锁
	- 类似两阶段锁，不过最后一阶段是 committed/abort 并写入磁盘日志后
- RollBack
	- Blocks
		- 当事务写入的时候，block被锁住，钉在内容中
		- 这时候只需要简单丢弃该block（将block放入可用空间中），等待下一次内存中断，从磁盘读入之前的（之前的事务都写入磁盘呢吗？）
		- 如果是多版本的，我们只需删去对应版本
	- smaller elements
		- 读磁盘的内容恢复：需要额外I/O
		- 读日志：需要查找大量日志
		- 为每个修改单独维护一个日志：需要更多的主存
- Group Commit