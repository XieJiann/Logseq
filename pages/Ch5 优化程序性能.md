- 序
    - 本节先介绍了编译器的局限，即为什么程序需要优化程序；
    - 制定了一个评判程序运行速度的指标CPE
    - 本节以一个程序为例，展现优化的过程
        - 首先，本节介绍了一些普遍性的优化方法
        - 然后，本节构建了一个机器模型（基于Intel和Amd），然后给出更多的优化方法
- 优化编译器的能力和局限性
    - gcc的优化选项
        - -Og
        - -O1
        - -O2
    - 优化的局限
        - 考虑之下的两个程序 ![image.jpg](../assets/a1ed8fc6-cbd9-4499-b0b8-cd08e440ae95-1115003.jpg)
            - 程序2需要3次内存引用（读*xp，读*yp，写*xp）；程序1需要6次引用；程序2是一个更好的优化版本
            - 当*xp和*yp指向同一个地方时，程序2的功能和程序1不一样（程序1增加4倍，程序1增加两倍）
            - 编译器不能确定两个指针是否指向同一个位置，所以编译器需要假设所有的可能，而这限制了编译器的优化策略
- 表示程序的性能
    - 每元素的周期数（Cycles Per Element，CPE）：对于一个程序，每增加一个元素的操作，程序运行时间需要增加多少个周期
    - 例子：考虑两个将n个元素累加的程序
        - psum1：直接累加 ![image.jpg](../assets/850dade5-9417-457c-ad4a-af7785fbc824-1115003.jpg)
        - psum2：将两个循环合并为1个 ![image.jpg](../assets/a5235d04-51f2-49a7-9c59-0333e06aeff4-1115003.jpg)
        - psum1和psum2的运行周期图 ![image.jpg](../assets/2b9e0bf1-84a6-41df-984f-6ea5fd37a988-1115003.jpg)
            - Circles(psum1) = 368+9.0*n（CPE=9）
            - Circles(psum2) = 368+6.0*n（CPE=6）
- 优化
    - 程序示例（之后优化都是以此为例子）
        - 结构体：一个结构，包含一个数组的首地址，和该数组的长度 ![image.jpg](../assets/b5ea30c0-c1bc-4502-b92e-191c808dfb7e-1115003.jpg)
        - 一些基本函数
            - 取值 ![image.jpg](../assets/128a9657-9ee6-44e1-979f-4b5fa12218e3-1115003.jpg)
            - 得到数组长度 ![image.jpg](../assets/a6fb3203-d9e7-4488-a48e-b068ca47e657-1115003.jpg)
        - 程序：使用某种运算，将一个向量中所有元素合并为一个值（累加，累乘）
            - 不同的宏定义：
                - 累加 ![image.jpg](../assets/abbbd6e0-c845-4f26-948a-c85d49b80ba2-1115003.jpg)
                - 累乘 ![image.jpg](../assets/83b4ded5-5e74-40c5-b7bb-7b2a66a970db-1115003.jpg)
            - 程序 ![image.jpg](../assets/32e363ce-b115-4646-92de-319bc7e3d548-1115003.jpg)
            - 起点：基础的CPE（作为对比，未优化【是直接翻译汇编，-Og应该也是有少量的优化?】的和-O1的） ![image.jpg](../assets/d2abda2c-687d-4f71-87f7-5c6d3222a89d-1115003.jpg)
    - 一些基本的优化
        - 消除循环的低效率
            - 优化版本combine2中，将vec_length(v)赋给一个length，作为边界条件（在combine1中，每次循环都需要调用vec_length(v)） ![image.jpg](../assets/abac3b1f-4158-4d5b-995a-25fd7c9f8cef-1115003.jpg)
            - 优化结果 ![image.jpg](../assets/831f47b5-de3f-41e3-a663-ddc613adcc88-1115003.jpg)
            - 这种优化方法称为代码移动：识别需要执行多次（循环）中结果不变的计算。将该计算移动到不会被多次求值的部分（循环外）
        - 减少过程调用
            - 优化版本combine3：减少对get_element的调用，使用一种数组的方式读出值 ![image.jpg](../assets/2237996a-691c-44f8-8a52-1725023881c3-1115003.jpg)
            - 优化结果：由于其他瓶颈的存在，所以CPE没有提升太多。（详细讨论在理解内存性能） ![image.jpg](../assets/7e7fab99-3495-43b4-8d4f-3b8843854132-1115003.jpg)
        - 消除不必要的内存引用
            - 对于combine3的汇编代码 ![image.jpg](../assets/ec14eab1-1919-4ab5-91ed-c00fcf4cbf8a-1115003.jpg)
                - 对于：*dest = *dest OP data[i]；即汇编第2、4行，会在循环中对内存反复引用
            - 优化版本combine4：在循环中，将结果存放在寄存器中，不用反复读写内存
                - 汇编版本 ![image.jpg](../assets/416dc5f4-aa2e-45bd-8c7a-18146b88d152-1115003.jpg)
                - 程序版本：这里的局部变量是以寄存器存储的 ![image.jpg](../assets/ac403002-6e63-47b7-946b-2314fe2a8781-1115003.jpg)
            - 优化结果：CPE大幅度下降 ![image.jpg](../assets/7883a752-678b-4425-96dc-185f0d9bce03-1115003.jpg)
            - 一些问题：
                - 考虑以下调用 ![image.jpg](../assets/c256ed99-d11f-4214-b510-52c6d8d649d1-1115003.jpg)
                    - combine3会把 累加结果写进 数组中
                    - combine4不会，它只是结合最初始版本的数组的元素 ![image.jpg](../assets/6c221ef1-e668-4288-8f7b-47be74a2b459-1115003.jpg)
                - 对于编译器而言，它会做更保守的优化（读写内存）；所以需要程序员根据需求做优化
    - 基于处理器建模的一些优化
        - 理解现代处理器
            - 现代处理器架构 ![image.jpg](../assets/c03c8725-8aa3-4190-a4c1-53160c17b2b1-1115003.jpg)
                - ICU
                    - ICU会在执行指令很早之前取指，这样它才有足够时间译码，并将其发送给EU
                    - ICU有一个重要部分是退役单元（Retirement unit）
                        - 寄存器文件（AVX、SSE和整数寄存器）是退役单元的一部分
                        - 指令译码时，关于指令的信息被放入一个队列中
                            - 当指令完成，而且所有引起这条指令的分支也被预测正确，那么该条指令退役，对寄存器的更新就可以执行了
                            - 当分支预测错误，该条指令会被清空，丢弃所有计算出来的结果
                - EU
                    - EU包含一组功能单元
                        - 计算功能：加法、乘法，浮点数
                        - 内存读写：加载、存储
                        - 控制：分支
                    - EU执行单元间数据传送
                        - 当一条更新寄存器r的指令译码时，产生标记t，得到一个指向该操作结果的唯一的标识符
                        - （r,t）被加入到一张表中，该表维护这 寄存器r 和 会更新该寄存器操作的标记t之间的关联
                        - 当以r寄存器作为操作数的指令译码时，发送到执行单元的操作会包含t作为操作数的值
                        - 当某个执行单元完成一个操作时，会生成一个结果（v,t），指明标记为t产生的结果v
                        - 所有等待t为源操作数都能使用v作为源值
            - 功能单元的性能 ![image.jpg](../assets/a61b2b83-fcb9-4937-b4fe-e0d417ee9b7c-1115003.jpg)
                - 延迟（Latency）：表示完成运算所需要的时间
                    - 加法完成每个运算只需要1个周期
                    - 浮点数完成需要三个周期
                        - 处理指数值
                        - 处理小数值
                        - 将结果进行舍入
                - 发射时间（issue time）：表示两个连续的同类型的运算之间   间隔 需要最小的周期数
                    - issue为1，说明是完全流水线化的，每个周期都能执行一条该运算
                    - 除法的发射时间等于延迟，说明开始一条新除法运算之前，上条除法运算必须完成
                - 容量：表示执行该运算功能单元的数量
                - 最大吞吐量
                    - 对于每个功能单元而言，吞吐量即为1/I，即每个周期可以执行1/I命令（完全流水线化的为1）
                    - 对于C个功能单元而言，其吞吐量C/I
                - 吞吐量延迟（即每个操作花费的时间，即吞吐量的倒数）和延迟决定了CPE的两种下限（处理器的操作模型      提高并行性） ![image.jpg](../assets/b640d684-dc3c-4150-8eac-66e8a3b20ed9-1115003.jpg)
                    - 整数加法为0.5的原因为处理器只有两个加载单元，所以每周期只能执行两个加法
            - 处理器操作模型
                - combine4的CPE（CPE和latency相近，下面的数据流图分析表明这不是个巧合） ![image.jpg](../assets/764b8275-7513-40c8-a64c-0afa76538a9c-1115003.jpg)
                - 从机器代码到数据流图（以COMBINE4为例子）
                    - 汇编代码 ![image.jpg](../assets/0cf9ba01-69a4-40e6-b93c-6b1cc4bb2310-1115003.jpg)
                    - 寄存器读写流程 ![image.jpg](../assets/d59a7b42-4d59-42be-99fa-f7b415ab168a-1115003.jpg)
                        - 顶部表明一开始的寄存器的值
                        - 底部表示最后寄存器的值
                        - 弧线表示数据传递（执行单元间的？）：load从内存读出结果传入mul，cmp会更新条件码，jne会测试条件码
                        - 四类寄存器
                            - 只读
                            - 只写
                            - 局部：在循环内部被修改和使用
                            - 循环：寄存器即作为源值，又作为目的，被反复读写
                    - 数据流图：循环寄存器之间的操作链决定了限制性能的数据相关（假设条件选择分支不影响，因为只在最后一次会预测错误，其它都会预测正确） ![image.jpg](../assets/fc607974-52fd-487d-8fae-d3b970ec7938-1115003.jpg)
                    - combine4的数据流图和关键路径 ![image.jpg](../assets/d8b524a2-f1d9-40e1-b2cd-4fb75d8fd4c1-1115003.jpg)
                        - 关键路径决定了CPE的下限（还可能有其它因素限制）
                        - 关键路径长为L*n，L即为关键路径全部操作（合并运算）的延迟
                - 例子：求多项式结果（这个例子体现了流水线的重要性，可参考提高并行性）
                    - 方法1： ![image.jpg](../assets/e9be7120-7ec0-4d39-963f-d90c28835520-1115003.jpg)
                        - 代码：CPE为5 ![image.jpg](../assets/ea1f0173-250a-4adc-a4f8-d20446a548cd-1115003.jpg)
                    - 方法2： ![image.jpg](../assets/b5e41bda-3d20-432a-aee2-780965eb9f66-1115003.jpg)
                        - 代码：CPE为8 ![image.jpg](../assets/66e2dfcc-a045-4568-80b0-69cccddd36c5-1115003.jpg)
                    - 为什么方法2的计算更少，CPE却更高
        - 循环展开
        - 提高并行性
    - 小结
- 一些限制因素
- 理解内存性能
- 性能提高技术（小结）
- 优化基本策略：确定和消除性能瓶颈
